package com.nus.pvt.reports.service;

import java.text.ParseException;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.nus.base.service.UserLoginBaseService;
import com.nus.fileupload.entities.ProjectMonthlyPlcc;
import com.nus.fileupload.entities.ProjectMonthlyResourceAllocation;
import com.nus.fileupload.entities.ProjectMonthlyResourceAttrition;
import com.nus.fileupload.entities.ProjectMonthlyResourceUtilization;
import com.nus.fileupload.service.MonthlyAttritionService;
import com.nus.fileupload.service.MonthlyRRRService;
import com.nus.fileupload.service.MonthlyResourceAllocationService;
import com.nus.fileupload.service.MonthlyResourceUtilizationService;
import com.nus.fileupload.service.ProjectMonthlyPlccService;
import com.nus.pvt.admin.entities.AssignProjectToPm;
import com.nus.pvt.admin.repo.AssignProjectToPmRepo;
import com.nus.pvt.reports.model.PmProjectReportModel;
import com.nus.pvt.reports.model.ProjectDetails;
import com.nus.util.Utility;

/**
 * @Author: SanjeevKumar<br>
 * @Date: 08-Feb-2025<br>
 * @Time: 4:01:12 pm<br>
 * @Objective: <br>
 */

@Service
public class PmAssignedProjectReportServiceImpl extends UserLoginBaseService implements PmAssignedProjectReportService {

	@Autowired
	AssignProjectToPmRepo assignProjectToPmRepo;

	@Override
	public PmProjectReportModel getPmReports(String fMonthYr, String tMonthYr) throws Exception {

		PmProjectReportModel pMProjectReportModel = null;
		try {
			List<AssignProjectToPm> assignProjectToPmList = assignProjectToPmRepo.findByPm(getCurrentLoginUserId(),
					activeC);
			if (assignProjectToPmList.size() != 0) {
				pMProjectReportModel = new PmProjectReportModel();
				pMProjectReportModel.setPm(assignProjectToPmList.get(0).getApexUser3().getName());
				pMProjectReportModel
						.setEmpGrade(assignProjectToPmList.get(0).getApexUser3().getUserGrade().getUserGrade());
				pMProjectReportModel.setfMonthYr(Utility.getDateInMMYYYY(fMonthYr));
				pMProjectReportModel.settMonthYr(Utility.getDateInMMYYYY(tMonthYr));
				pMProjectReportModel.setReportFor(Utility.monthsBetweenDates(fMonthYr, tMonthYr) + " - Month");
			}
			ProjectDetails projectDetails;
			for (AssignProjectToPm assignProjectToPm : assignProjectToPmList) {
				projectDetails = new ProjectDetails();
				projectDetails.setAssignedOn(dateFormatter.format(assignProjectToPm.getAssignedOn()));

				if (assignProjectToPm.getReleasedOn() != null)
					projectDetails.setReleasedOn(dateFormatter.format(assignProjectToPm.getReleasedOn()));
				if (assignProjectToPm.getProjectClosedOn() != null)
					projectDetails.setClosedOn(dateFormatter.format(assignProjectToPm.getProjectClosedOn()));

				projectDetails.setClientAccount(assignProjectToPm.getClientAccountMstr().getClientAccount());
				projectDetails.setProjectVertical(assignProjectToPm.getProjectVerticalMstr().getVerticalName());
				projectDetails.setProjectCode(assignProjectToPm.getProjectCodeMstr().getProjectCode());
				projectDetails.setProjectName(assignProjectToPm.getProjectCodeMstr().getProjectName());
				projectDetails.setProjectType(assignProjectToPm.getProjectTypeMstr().getProjectType());

				prepareOtherProjectSpecificData(assignProjectToPm.getProjectCodeId(), projectDetails, fMonthYr,
						tMonthYr);

				pMProjectReportModel.getProjectDetailReportList().add(projectDetails);
			}
		} catch (Exception ex) {
			throw ex;
		}
		return pMProjectReportModel;
	}

	private void prepareOtherProjectSpecificData(int projectCodeId, ProjectDetails projectDetails, String fMonthYr,
			String tMonthYr) throws ParseException {

		int fMonthNo = Utility.getFromMonthNo(fMonthYr);
		int fYear = Utility.getFYear(fMonthYr);
		int tMonthNo = Utility.getToMonthNo(tMonthYr);
		int tYear = Utility.getTYear(tMonthYr);

		// PLCC
		preparePLCC(projectCodeId, projectDetails, fMonthNo, tMonthNo, fYear, tYear);
		// Utilization
		prepareUtilization(projectCodeId, projectDetails, fMonthNo, tMonthNo, fYear, tYear);
		// Attrition
		prepareAttrition(projectCodeId, projectDetails, fMonthNo, tMonthNo, fYear, tYear);

		prepareAllocation(projectCodeId, projectDetails, fMonthNo, tMonthNo, fYear, tYear);
		prepareRRRR(projectCodeId, projectDetails, fMonthNo, tMonthNo, fYear, tYear);

	}

	/**
	 * @Objective: All PLCC related data will be prepared here for a particular
	 *             project. Implemented.
	 */
	@Autowired
	ProjectMonthlyPlccService projectMonthlyPlccService;

	private void preparePLCC(int projectCodeId, ProjectDetails projectDetails, int fMonth, int tMonth, int fYear,
			int tYear) {
		List<ProjectMonthlyPlcc> monthlyPlccBetweenMonthsList = projectMonthlyPlccService
				.getMonthlyPlccBetweenMonths(projectCodeId, fMonth, tMonth, fYear, tYear);

		// Full time employee [FTE] will come from PLcc using H-column.
		double fTeForYTD = 0;
		double marginAmountForYTD = 0;
		double totalRevenueAmountForYTD = 0;

		for (ProjectMonthlyPlcc projectMonthlyPlcc : monthlyPlccBetweenMonthsList) {
			fTeForYTD = fTeForYTD + projectMonthlyPlcc.getFte();
			marginAmountForYTD = marginAmountForYTD + projectMonthlyPlcc.getMarginAmount();
			totalRevenueAmountForYTD = totalRevenueAmountForYTD + projectMonthlyPlcc.getTotalRevenueAmount();
		}

		projectDetails.setyTDFte(fTeForYTD);
		projectDetails.setRevenuePerFTE(totalRevenueAmountForYTD/marginAmountForYTD);// Needs to be crecked
		projectDetails.setyTDPmPercent((marginAmountForYTD / totalRevenueAmountForYTD) * 100 + " %");
		
		 double costPerFTE = (totalRevenueAmountForYTD - marginAmountForYTD)/fTeForYTD;
		 projectDetails.setCostPerFTE(costPerFTE);
	}

	/**
	 * @Objective: All Resource-Utilization related data will be prepared here for a
	 *             particular project. Both data will be taken from utilization
	 *             table. Implemented.
	 */
	@Autowired
	MonthlyResourceUtilizationService monthlyResourceUtilizationService;

	private void prepareUtilization(Integer projectCodeId, ProjectDetails projectDetails, int fMonth, int tMonth,
			int fYear, int tYear) {
		List<ProjectMonthlyResourceUtilization> monthlyResourceUtilizationList = monthlyResourceUtilizationService
				.getMonthlyResourceUtilizationBetweenMonths(projectCodeId, fMonth, tMonth, fYear, tYear);
//YTD Utilization percentage
		double billedDaysSumForYTD = 0;
		double availableDaysSumForYTD = 0;
		for (ProjectMonthlyResourceUtilization monthlyResourceUtilizationForYTD : monthlyResourceUtilizationList) {
			billedDaysSumForYTD = billedDaysSumForYTD + monthlyResourceUtilizationForYTD.getBilledDays();
			availableDaysSumForYTD = availableDaysSumForYTD + monthlyResourceUtilizationForYTD.getAvailableDays();
		}
		projectDetails.setyTDUtilPercent((billedDaysSumForYTD / availableDaysSumForYTD) * 100 + " %");

//Utilization for 2 month back from given toMonth
		int twoMonthBackYear = 0;
		int twoMonthBackMonthNo = tMonth - 2;
		if (twoMonthBackMonthNo > 0)
			twoMonthBackYear = tYear;
		else
			twoMonthBackYear = tYear - 1;
		// Reinitialize for cleaning the staled data
		billedDaysSumForYTD = 0;
		availableDaysSumForYTD = 0;
		monthlyResourceUtilizationList = monthlyResourceUtilizationService.getMonthlyResourceUtilizationBetweenMonths(
				projectCodeId, fMonth, twoMonthBackMonthNo, fYear, twoMonthBackYear);

		for (ProjectMonthlyResourceUtilization monthlyResourceUtilizationForYTD : monthlyResourceUtilizationList) {
			billedDaysSumForYTD = billedDaysSumForYTD + monthlyResourceUtilizationForYTD.getBilledDays();
			availableDaysSumForYTD = availableDaysSumForYTD + monthlyResourceUtilizationForYTD.getAvailableDays();
		}
		projectDetails.setTwoMonthBackMonthUtilPercent((billedDaysSumForYTD / availableDaysSumForYTD) * 100 + " %"
				+ Utility.getMonthName(twoMonthBackMonthNo));

		// ProjectMonthlyResourceUtilization monthlyResourceUtilization =
		// monthlyResourceUtilizationService
		// .getAMonthSpecificResourceUtilization(projectCodeId, twoMonthBackMonthNo,
		// twoMonthBackYear);

		/*
		 * double billedDaysForAMonth = 0; double availableDaysForAMonth = 0;
		 * billedDaysForAMonth = monthlyResourceUtilization.getBilledDays();
		 * availableDaysForAMonth = monthlyResourceUtilization.getAvailableDays();
		 * projectDetails.setTwoMonthBackMonthUtilPercent((billedDaysForAMonth /
		 * availableDaysForAMonth)*100 + " % in " +
		 * Utility.getMonthName(twoMonthBackMonthNo));
		 */

	}

	/**
	 * @Objective: All Resource-Attrition related data will be prepared here for a
	 *             particular project
	 */
	@Autowired
	MonthlyAttritionService monthlyAttritionService;

	private void prepareAttrition(Integer projectCodeId, ProjectDetails projectDetails, int fMonthNo, int tMonthNo,
			int fYear, int tYear) {
		// YTD Attrition calculation
		double ytd_attrition_percent = calculateYTDAttritionPercent(projectCodeId, fMonthNo, tMonthNo, fYear, tYear);
		projectDetails.setyTDAttritionPercent(ytd_attrition_percent + " %");
		// Attrition for current month. [total_exit_count/ Total_resource_count] for
		// current month
		int currentMonthYear = tYear;
		int currentMonthNo = tMonthNo;
		double currentMonthAttritionPercent = currentMonthAttritionPercent(projectCodeId, currentMonthNo,
				currentMonthYear);
		projectDetails.setCurrentAttritionPercent(
				currentMonthAttritionPercent + " % in " + Utility.getMonthName(currentMonthNo));
	}// End of prepareAttrition

	private double calculateYTDAttritionPercent(Integer projectCodeId, int fMonthNo, int tMonthNo, int fYear,
			int tYear) {
		int total_exit_count = calculateYTDTotalExitCount(projectCodeId, fMonthNo, tMonthNo, fYear, tYear);
		int total_resource_count = calculateYTDTotalResourceAllocationCount(projectCodeId, fMonthNo, tMonthNo, fYear,
				tYear);
		double ytd_attrition_percent = (total_exit_count / total_resource_count) * 100;
		return ytd_attrition_percent;
	}

	// Here, we will count total no. of resource exit from a project using Attrition
	// table. This counting will be made
	// between fMonth to tMonth input and project_id.
	private int calculateYTDTotalExitCount(Integer projectCodeId, int fMonthNo, int tMonthNo, int fYear, int tYear) {
		// YTD Attrition percentage [total_exit_count/ Total_resource_count] per
		// project.total_exit_count will come from attrition table and
		// Total_resource_count(Distinct) will come from
		// allocation table. In case of multiple records the highest allocation column
		// should be picked.

		List<ProjectMonthlyResourceAttrition> projectMonthlyResourceAttritionList = monthlyAttritionService
				.getMonthlyResourceAttritionDataBetweenMonths(projectCodeId, fMonthNo, tMonthNo, fYear, tYear);
		int total_exit_count = projectMonthlyResourceAttritionList.size();

		return total_exit_count;
	}

	// Here, we will count distinct resource allocation project wise between from
	// month and to month.
	// Remark: if the same resource allocation is found more than one time in a
	// month as a billable and non-billable,
	// then we will pick the highest allocation value rows. Still need to discuss
	// it.
	@Autowired
	MonthlyResourceAllocationService monthlyResourceAllocationService;

	private int calculateYTDTotalResourceAllocationCount(Integer projectCodeId, int fMonthNo, int tMonthNo, int fYear,
			int tYear) {

		List<ProjectMonthlyResourceAllocation> projectMonthlyResourceAllocationList = monthlyResourceAllocationService
				.getMonthlyDistinctResourceAllocationBetweenMonths(projectCodeId, fMonthNo, tMonthNo, fYear, tYear);
		int totalResourceAllocationCount = projectMonthlyResourceAllocationList.size();
		return totalResourceAllocationCount;
	}

	// Here, we have to calculate attrition value for the current month only using
	// the same approach that we have used for its corresponding YTD
	private double currentMonthAttritionPercent(Integer projectCodeId, int currentMonthNo, int currentMonthYear) {

		List<ProjectMonthlyResourceAttrition> monthlyResourceAttritionList = monthlyAttritionService
				.getAMonthSpecificAttrition(projectCodeId, currentMonthNo, currentMonthYear);

		List<ProjectMonthlyResourceAllocation> resourceAllocationForCurrentLMonthist = monthlyResourceAllocationService
				.getDistinctResourceAllocationForCurrentMonth(projectCodeId, currentMonthNo, currentMonthYear);

		int totalResourceAllocationCount = resourceAllocationForCurrentLMonthist.size();
		int total_exit_count = monthlyResourceAttritionList.size();
		double currentMonthAttritionPercent = (total_exit_count / totalResourceAllocationCount) * 100;
		return currentMonthAttritionPercent;
	}

	

	// Here,Expected Increase P/M column data will be picked for RRRR [Potential
	// FTE]. It will be count of non-zero data of [Expected Increase P/M] for a project.
	// RRRR (Potential Rev/ Month) => Sum of all data [Expected Increase P/M] available for a month
	@Autowired
	MonthlyRRRService monthlyRRRService;
	private void prepareRRRR(int projectCodeId, ProjectDetails projectDetails, int fMonthNo, int tMonthNo, int fYear,
			int tYear) {
		monthlyRRRService.getMonthlyExpectedIncreasePM_RRRR(projectCodeId, fMonthNo, tMonthNo, fYear, tYear);
		
		
	}

	private Object M_RRRR(int projectCodeId, int fMonthNo, int tMonthNo, int fYear, int tYear) {
		// TODO Auto-generated method stub
		return null;
	}

	// Here,
	private void prepareAllocation(int projectCodeId, ProjectDetails projectDetails, int fMonthNo, int tMonthNo,
			int fYear, int tYear) {
		// TODO Auto-generated method stub
	}
}
